<resources>
    <string name="app_name">Chris Parsons</string>

    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>

    <string name="action_settings">Settings</string>

    // HOME PAGE
    <string name="home_heading">My App</string>
    <string name="title_activity_tools">Covering an assortment of tools and frameworks for a range of testing written in a few different languages</string>

    // THIS APP PAGE
    <string name="this_site_heading">Why have I done this?</string>
    <string name="this_site_desc">A bit of Android, a bit of Java, some Gradle and some TeamCity.</string>

    <string name="this_app_heading">This Application</string>
    <string name="this_app_desc">The application is basically just a dummy app to test against. It contains a few functions, so that the test environment has something relatively sensible and real to test against.</string>

    <string name="whats_in_it_heading">What is in it?</string>
    <string name="whats_in_it_desc">The full build makes use of Debian Jessie, TeamCity, MySQL, GitHub, Android SDK and Appium. Occasionally, such as with the carousel, it also makes use of gradle plugins to supply libraries.</string>

    <string name="why_heading">Why?</string>
    <string name="why_desc">My intention in creating this app was to get a bit of exposure to TeamCity, to Android and most importantly to mobile testing via Appium. Having only focused used ExperiTest SeeTest very briefly to automate browser tests on an iPad and a TabPro, I wanted to get a bit of understanding about how to test a developed APK. As Android Studio uses gradle and an IDE based on IntelliJ, both of which I’ve already used, it seemed slightly easier to get into.\n\n</string>


    // MENU STRINGS
    <string name="home_icon">&#xf015;</string>
    <string name="tools_icon">&#xf013;</string>
    <string name="other_tools_icon">&#xf17c;</string>
    <string name="this_app_icon">&#xf17b;</string>
    <string name="github_icon">&#xf09b;</string>

    // TOOLS PAGE
    <string name="tools_heading">Tools and Frameworks</string>
    <string name="tools_examples">Select an option from the tabs to see their content.</string>

    <string name="tools_jasmine">The first code on the website checks the login method in an authentication module. The login method was a factory that executed a $http POST request, and returned a success or error callback.\n\n A challenge of testing HTTP requests is that a mock backend server needs to be in place, returning a known result to test against. The angular-supplied $httpBackend allows expectXXX methods to set up the responses for the request made.\n\n In the example on the site, it is expected that if the user supplies invalid credentials a 500 error should be returned, while valid credentials would return 200 success.\n\n Once the method is executed, the backend must be flushed to allow the request to be made and for the server to execute the expected response. If the backend is not flushed, the test will get to the .success and then not go any further. \n\nThe spy at the end of the test verifies that the callback is successfully executed. \n\nThe other bit of code checks that when a file is uploaded, it is seen as ‘added’ if it contains a .txt extension. The ‘flow’ module an angular extension that allows for a button click or drag and drop of a file to upload to a server, so the test has to first set up the mock file to upload. \n\nOne of the main difficulties in this test involves mocking a window so that when the window opens a new URL, you don’t get a ‘Some of your tests did a full page reload!’ error. Mocking is a large part of the setup for Jasmine tests. The tests can often take minutes to write, with the environment setup taking the bulk of the time.\n\n</string>
    <string name="tools_protractor">Protractor works by loading a Selenium server instance and executing selenium tests on the browser set in the capabilities of the config file. The code on the website is basically identical to that of the Selenium example, except written in Javascript. Libraries are used and imported using ‘require’, and assert() has been replaced by the expect() which is also used in Jasmine syntax. For writing both unit and E2E tests together, Protractor offers a lot of syntactical benefits. \n\nHowever, browser.waits are often fairly brittle and even built in expected conditions are susceptible to stale element errors.\n\n</string>
    <string name="tools_uiautomation">The first of 3 examples on the website attempts to mimic Selenium\’s waitUntil WebDriverWait method. As each element is returned in its own method within the PageObjects class, the function needs to be able to determine the object to use by its method name. \n\nIn this case, reflection is used to invoke the method by the element name passed in. The function has to behave in this way because page object is only returned if a scan of the available objects returns a result. \nIf the object was passed in, it would always have the same status (not available) throughout the process because it is an object created from a class and not a dynamic element. If the timer expires, a failure assertion is thrown so the test fails. These tests are executed using nUnit.\n\n</string>
    <string name="tools_jmeter">JMeter gives a tester a few performance measuring sticks to apply to their service, be it data throughput or coping with stress and load, or for checking that all requests are met with a response. \n\nJMeter stores data as .JMX which is basically a JMeter XML file. Getting information directly from the JMX file is difficult, so the GUI is used to parse the data. \n\nIn the example on the website, the application is being checked by creating, deleting and copying/pasting the data stored within the service. The tests use standard HTTP GET, DELETE, PUT commands to do this. The reports at the bottom of the example show throughput and response times, and allow for manual checking the times fall within the expected ranges. \n\nThis can be easily tied into a maven or gradle build via plugins, and is currently used to check general stability of each build created with an automated report delivered on completion.\n\n</string>
    <string name="tools_othertools">TestComplete is a tool from SmartBear for automation of mobile, web and desktop apps. Most of the code written with TestComplete was in C#-script, which is a hybrid of Javascript and C# without really being similar to either of them. The framework itself is very easy to get into, as a lot of the heavy lifting is done for you. Whereas with other frameworks you may need to devise your own application object model, TestComplete does this for you.\n\nSikuli is a framework that uses image recognition. Relying on image recognition only in test cases has some serious limitations, but combining it with Selenium meant that DOM objects could be manipulated but the actual look and feel of the UI could be verified at the same time. As the tool uses image recognition, a lot of images need to be stored which can bloat a project’s size. The language used in Sikuli is python.\n\nRobot Framework is a very high-level test runner. Tests can be written by piecing together keywords, with the libraries those keywords call sitting underneath. It feels like a cumbersome tool, but was very useful for combing Sikuli and Selenium into one suite.\n\n</string>
    <string name="new_selenium_tools">The first simple test example logs in to the application as part of the @BeforeClass, and then clicks on each tab in the page and verifies their content. \n\nOnce the test is complete, the content is cleared so each test begins with the same data present, and at the end of the suite the driver is closed. The @Rule allows for screenshots to be taken on a failing test by overriding the failed method in the abstract TestWatcher jUnit class.\n\nThe login method that Example 1 uses shows how to a) resize a window if needed and b) bypasses internet explorers certification requirement. A Javascript executor is used to do this. \n\nThe Javascript executor method can also be extremely useful for scrolling to elements on the page that aren’t visible, and has been used frequently for unhiding hidden browse to file buttons.\n\nThe third example shows the creation of a webdriver using Python bindings. There are some weird bits, like visibility of element requiring double parentheses around the locator and some of the syntax is slightly different elsewhere too, but generally if you can use the Java version it’s reasonably easy to get set up with Python. \n\nThis specific class allows for the driver to be setup, so that when the module is imported and used in a different class, the method is available. But it also contains the ‘if __name__ == "__main__":’ statement at the bottom, which means it can be run in isolation (ie doesn’t need anything else to make the method execute). \n\nI’m using PyCharm (JetBrains) as an IDE, and when I execute the script it automatically passes the name as __main__, which it wouldn’t do if the module was imported.\n\nThe last example shows a full example of how a login page might be tested. As in all of the examples from other projects, the test suite is broken out into objects, methods and the tests. \n\nThe Python bindings differ from Java in that the expected conditions class doesn’t have a urlContains method included, so this has to be manually created. This one basically looks to see if the URL contains the string supplied, and while it doesn’t it waits for a second. \n\nIf the time meets the wait count supplied by the user, an exception is thrown and the test fails. The unit testing framework is implemented through inheritance, and is the standard unit test tool supplied for Python. \n\nThe setup and teardown methods are specific to unittest.TestCase and are run at the beginning and end of each test case. The setUpClass and tearDownClass methods can be used to bookend the test suite too.\n\n</string>
    <string name="tools_api">The REST API uses the URI of HTTP Requests to GET and DELETE resources, whilst using the body of the request to POST or PUT resources.\n\nThe API examples on the website show usage of Mocha (JS), Rest Assured (Java) and Rest Sharp (C#), as well as an example of a request and response using the Marvel API. \n\nAway from automation, the API can be tested using Poster (Firefox), Postman (Chrome), DHC or any other REST client.\n\n </string>
    <string name="my_api"></string>

    // OTHER TOOLS PAGE
    <string name="other_tools_heading">Other Tools</string>
    <string name="other_tools_desc">The accompanying software and tools that are used as aides to testing, rather than the frameworks themselves.</string>
    <string name="other_tools_examples">Select an option from the tabs to see their content.</string>

    <string name="other_tools_jenkins">Jenkins is a web service used to execute tasks set by a trigger. The service can be deployed by a web server as a WAR, or as an installed Windows service. \n\nI have Jenkins installed on Raspbian as a service under /etc/init.d/Jenkins and on a Windows machine as a service. As of Jenkins 2.0, Maven projects require a plugin to run as a Maven-specific project, otherwise all projects are considered Freestyle. \n\nThe POM or build.gradle location is set in the configuration and trigger options set. \n\n</string>
    <string name="other_tools_linux">The example on the site shows login and file permission editing through SSH. In this case, the SSH application is used but programs like PuTTY do the same thing. Files can be transferred across to a remote Linux machine using an FTP application like Filezilla. These methods are particularly useful when setting up a server with no GUI, such as a Raspberry Pi. \n\nThe website has been maintained using Ubuntu 15.10, and sits on a partitioned laptop with Mint 17.3. I’ve also used SUSE Linux Enterprise Server in a previous role. \n\nThis app has been developed using Debian Jessie (8), and the installation process and background of the Android project can be found on my website. \n\n</string>
    <string name="other_tools_mocking">The Java MockServer allows for an external service on which my application is dependent to be mocked, so that any requests my application makes can be responded to correctly. \n\nFor example, if my application was to send a GET request to /path/to/my/rest/services, I could expect a response containing my service data which would allow me to carry on testing my application. \n\nWithout the mock, I would only be able to test up until the point that a request is made. Mockserver is a netty-based service, and can be installed from mavencentral using a compile \'org.mock-server:mockserver-netty:3.10.4\' in the build.gradle file for the test suite. \n\nThe other examples on the website use Angular\’s HTTPBackend to mock service responses for Jasmine tests. The first example checks the data returned matches what is expected, while the second example checks that an action occurs as a result of an error callback in the request. \n\n</string>
    <string name="other_tools_buildenv">Maven uses an XML syntax which is very verbose and not particularly easy on the eye. As all dependency injections and tasks require open/closing tags (as all XML documents do), the actual content of the build environment is pretty minimal compared to the framework that sits around it. \n\nGradle uses Groovy, which is a lot easier to view and gives as much flexibility as Maven without the need for tags everywhere. \n\nApplying dependencies in Gradle can be performed by using the compile command. The Java plugin allows for the test{ } section to be used, which means the user can access tests by gradlew module:test. Custom tasks can also be accessed this way. \n\nIf I wanted to execute the copyMyApplicationLogs task, I could use gradlew module:copyMyApplicationLogs which would only copy logs from one destination to the other. If I chose to run gradlew module:installMyApplication, it would first execute the build task in the ‘buildmyapp’ module because of the dependency stated, and then go onto execute this task if the build task was successful. \n\nGit can be used to collect or submit data to a private or public repository. The example shows some fairly basic examples, but the notable ones are clone, pull, status, add, commit and push. Clone allows a user to clone a whole repository, for example from GitHub or Bitbucket. \n\nIf a repository has already been cloned, the ‘git pull’ command collects the latest versions of any updated files between the user’s current working copy and the latest one. Once changes are made (which can be viewed with git status), git add will add all of the data to the staging area. Git commit –m”*message*” will commit the data to a stored push request. Git push –u destination source then pushes the changes into the repository for other people to use. All of this website has been changed using Git (it’s on GitHub…). \n\n</string>
    <string name="npm_again">Modules can be installed directly from npm using the npm install modulename command. \n\nNPM has been used to install a lot of node modules, including karma, jasmine and protractor as test frameworks and runners, as well as supplementary functions like require and should. \n\nNPM is the package manager which is bundled with node, so allows access to a lot of node-related resources. My website hosted on the Pi Zero uses Forever, which is an npm module.\n\n</string>

    // ALL PAGES.
    <string name="examples_link">* For examples, see http://chrisp1985.github.io</string>
</resources>
